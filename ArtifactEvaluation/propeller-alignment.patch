diff --git a/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h b/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
index cd27fea771ba..f28d7ae747ae 100644
--- a/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
+++ b/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
@@ -23,6 +23,7 @@
 #include "llvm/IR/Module.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
+#include "llvm/Support/BranchProbability.h"
 #include "llvm/Support/Error.h"
 #include "llvm/Support/LineIterator.h"
 #include "llvm/Support/MemoryBuffer.h"
@@ -40,7 +41,13 @@ struct BBClusterInfo {
   unsigned PositionInCluster;
 };
 
-using ProgramBBClusterInfoMapTy = StringMap<SmallVector<BBClusterInfo>>;
+struct PropellerProfile {
+  SmallVector<BBClusterInfo> FunctionClusterInfo;
+  DenseMap<unsigned, unsigned> NodeFrequency;
+  DenseMap<unsigned, DenseMap<unsigned, unsigned>> EdgeFrequency;
+};
+
+using ProgramBBClusterInfoMapTy = StringMap<PropellerProfile>;
 
 class BasicBlockSectionsProfileReader : public ImmutablePass {
 public:
@@ -71,8 +78,11 @@ public:
   // function. If the first element is true and the second element is empty, it
   // means unique basic block sections are desired for all basic blocks of the
   // function.
-  std::pair<bool, SmallVector<BBClusterInfo>>
-  getBBClusterInfoForFunction(StringRef FuncName) const;
+  std::pair<bool, PropellerProfile>
+  getPropellerProfileForFunction(StringRef FuncName) const;
+
+  BranchProbability getEdgeProbability(StringRef FuncName, unsigned FromBBID,
+                                       unsigned ToBBID) const;
 
   // Initializes the FunctionNameToDIFilename map for the current module and
   // then reads the profile for matching functions.
diff --git a/llvm/lib/CodeGen/BasicBlockSections.cpp b/llvm/lib/CodeGen/BasicBlockSections.cpp
index 33e70b160d92..be93a3cbaf72 100644
--- a/llvm/lib/CodeGen/BasicBlockSections.cpp
+++ b/llvm/lib/CodeGen/BasicBlockSections.cpp
@@ -176,19 +176,19 @@ bool getBBClusterInfoForFunction(
     DenseMap<unsigned, BBClusterInfo> &V) {
 
   // Find the assoicated cluster information.
-  std::pair<bool, SmallVector<BBClusterInfo, 4>> P =
-      BBSectionsProfileReader->getBBClusterInfoForFunction(MF.getName());
+  std::pair<bool, PropellerProfile> P =
+      BBSectionsProfileReader->getPropellerProfileForFunction(MF.getName());
   if (!P.first)
     return false;
 
-  if (P.second.empty()) {
+  if (P.second.FunctionClusterInfo.empty()) {
     // This indicates that sections are desired for all basic blocks of this
     // function. We clear the BBClusterInfo vector to denote this.
     V.clear();
     return true;
   }
 
-  for (const BBClusterInfo &BBCI : P.second)
+  for (const BBClusterInfo &BBCI : P.second.FunctionClusterInfo)
     V[BBCI.BBID] = BBCI;
   return true;
 }
diff --git a/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp b/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
index 5dede452ec34..c21fff5021e3 100644
--- a/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
+++ b/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
@@ -20,6 +20,8 @@
 #include "llvm/ADT/StringRef.h"
 #include "llvm/CodeGen/Passes.h"
 #include "llvm/IR/DebugInfoMetadata.h"
+#include "llvm/Support/BlockFrequency.h"
+#include "llvm/Support/BranchProbability.h"
 #include "llvm/Support/Error.h"
 #include "llvm/Support/LineIterator.h"
 #include "llvm/Support/MemoryBuffer.h"
@@ -34,16 +36,29 @@ INITIALIZE_PASS(BasicBlockSectionsProfileReader, "bbsections-profile-reader",
                 false)
 
 bool BasicBlockSectionsProfileReader::isFunctionHot(StringRef FuncName) const {
-  return getBBClusterInfoForFunction(FuncName).first;
+  return getPropellerProfileForFunction(FuncName).first;
 }
 
-std::pair<bool, SmallVector<BBClusterInfo>>
-BasicBlockSectionsProfileReader::getBBClusterInfoForFunction(
+std::pair<bool, PropellerProfile>
+BasicBlockSectionsProfileReader::getPropellerProfileForFunction(
     StringRef FuncName) const {
   auto R = ProgramBBClusterInfo.find(getAliasName(FuncName));
-  return R != ProgramBBClusterInfo.end()
-             ? std::pair(true, R->second)
-             : std::pair(false, SmallVector<BBClusterInfo>{});
+  return R != ProgramBBClusterInfo.end() ? std::pair(true, R->second)
+                                         : std::pair(false, PropellerProfile());
+}
+
+BranchProbability BasicBlockSectionsProfileReader::getEdgeProbability(
+    StringRef FuncName, unsigned FromBBID, unsigned ToBBID) const {
+  auto R = getPropellerProfileForFunction(FuncName);
+  if (!R.first)
+    return BranchProbability();
+  unsigned FromFreq = R.second.NodeFrequency.lookup(FromBBID);
+  if (FromFreq == 0)
+    return BranchProbability();
+  auto EdgesFrom = R.second.EdgeFrequency.lookup(FromBBID);
+  if (EdgesFrom.empty())
+    return BranchProbability(0, FromFreq);
+  return BranchProbability(EdgesFrom.lookup(ToBBID), FromFreq);
 }
 
 // Basic Block Sections can be enabled for a subset of machine basic blocks.
@@ -65,7 +80,7 @@ BasicBlockSectionsProfileReader::getBBClusterInfoForFunction(
 // !!4
 Error BasicBlockSectionsProfileReader::ReadProfile() {
   assert(MBuf);
-  line_iterator LineIt(*MBuf, /*SkipBlanks=*/true, /*CommentMarker=*/'#');
+  line_iterator LineIt(*MBuf, /*SkipBlanks=*/true);
 
   auto invalidProfileError = [&](auto Message) {
     return make_error<StringError>(
@@ -87,6 +102,29 @@ Error BasicBlockSectionsProfileReader::ReadProfile() {
 
   for (; !LineIt.is_at_eof(); ++LineIt) {
     StringRef S(*LineIt);
+    if (S[0] == '#') {
+      if (FI == ProgramBBClusterInfo.end())
+        continue;
+      if (!S.consume_front("#cfg-prof "))
+        continue;
+      SmallVector<StringRef, 4> BlockProfile;
+      S.split(BlockProfile, ' ');
+      auto R = BlockProfile[0].split(/*Separator=*/':');
+      unsigned long long BBID, Freq;
+      if (getAsUnsignedInteger(R.first, 10, BBID) ||
+          getAsUnsignedInteger(R.second, 10, Freq))
+        return invalidProfileError("unable to read frequency profile");
+      FI->second.NodeFrequency[BBID] = Freq;
+      for (size_t I = 1; I < BlockProfile.size(); ++I) {
+        auto R = BlockProfile[I].split(/*Separator=*/':');
+        unsigned long long SinkBBID, EdgeFreq;
+        if (getAsUnsignedInteger(R.first, 10, SinkBBID) ||
+            getAsUnsignedInteger(R.second, 10, EdgeFreq))
+          return invalidProfileError("unable to read edge frequency profile");
+        FI->second.EdgeFrequency[BBID][SinkBBID] = EdgeFreq;
+      }
+      continue;
+    }
     if (S[0] == '@')
       continue;
     // Check for the leading "!"
@@ -113,7 +151,7 @@ Error BasicBlockSectionsProfileReader::ReadProfile() {
         if (BBID == 0 && CurrentPosition)
           return invalidProfileError("Entry BB (0) does not begin a cluster.");
 
-        FI->second.emplace_back(
+        FI->second.FunctionClusterInfo.emplace_back(
             BBClusterInfo{((unsigned)BBID), CurrentCluster, CurrentPosition++});
       }
       CurrentCluster++;
diff --git a/llvm/lib/CodeGen/MachineBasicBlock.cpp b/llvm/lib/CodeGen/MachineBasicBlock.cpp
index 280ced65db7d..2213e80b648b 100644
--- a/llvm/lib/CodeGen/MachineBasicBlock.cpp
+++ b/llvm/lib/CodeGen/MachineBasicBlock.cpp
@@ -952,6 +952,8 @@ bool MachineBasicBlock::isSuccessor(const MachineBasicBlock *MBB) const {
 }
 
 bool MachineBasicBlock::isLayoutSuccessor(const MachineBasicBlock *MBB) const {
+  if (SectionID != MBB->getSectionID())
+    return false;
   MachineFunction::const_iterator I(this);
   return std::next(I) == MachineFunction::const_iterator(MBB);
 }
diff --git a/llvm/lib/CodeGen/MachineBlockPlacement.cpp b/llvm/lib/CodeGen/MachineBlockPlacement.cpp
index 912e9ec993e3..045a3367532b 100644
--- a/llvm/lib/CodeGen/MachineBlockPlacement.cpp
+++ b/llvm/lib/CodeGen/MachineBlockPlacement.cpp
@@ -34,6 +34,7 @@
 #include "llvm/ADT/Statistic.h"
 #include "llvm/Analysis/BlockFrequencyInfoImpl.h"
 #include "llvm/Analysis/ProfileSummaryInfo.h"
+#include "llvm/CodeGen/BasicBlockSectionsProfileReader.h"
 #include "llvm/CodeGen/MBFIWrapper.h"
 #include "llvm/CodeGen/MachineBasicBlock.h"
 #include "llvm/CodeGen/MachineBlockFrequencyInfo.h"
@@ -380,6 +381,8 @@ class MachineBlockPlacement : public MachineFunctionPass {
   /// A handle to the function-wide block frequency pass.
   std::unique_ptr<MBFIWrapper> MBFI;
 
+  const BasicBlockSectionsProfileReader *BBSectionsProfileReader;
+
   /// A handle to the loop info.
   MachineLoopInfo *MLI = nullptr;
 
@@ -585,8 +588,10 @@ class MachineBlockPlacement : public MachineFunctionPass {
   /// Modify the existing block placement in the function and adjust all jumps.
   void assignBlockOrder(const std::vector<const MachineBasicBlock *> &NewOrder);
 
+  void applyBlockOrder(MachineFunction &MF);
+
   /// Create a single CFG chain from the current block order.
-  void createCFGChainExtTsp();
+  void createCFGChainFromCurrentBlockOrder();
 
 public:
   static char ID; // Pass identification, replacement for typeid
@@ -2903,7 +2908,14 @@ void MachineBlockPlacement::alignBlocks() {
   if (FunctionChain.begin() == FunctionChain.end())
     return; // Empty chain.
 
+  bool BBSections = BBSectionsProfileReader && F->hasBBSections();
+
   const BranchProbability ColdProb(1, 5); // 20%
+  BlockFrequency BBSectionsEntryFreq =
+      BBSections ? BBSectionsProfileReader
+                       ->getPropellerProfileForFunction(F->getName())
+                       .second.NodeFrequency.lookup(0)
+                 : 1;
   BlockFrequency EntryFreq = MBFI->getBlockFreq(&F->front());
   BlockFrequency WeightedEntryFreq = EntryFreq * ColdProb;
   for (MachineBasicBlock *ChainBB : FunctionChain) {
@@ -2918,22 +2930,32 @@ void MachineBlockPlacement::alignBlocks() {
     if (!L)
       continue;
 
-    const Align Align = TLI->getPrefLoopAlignment(L);
-    if (Align == 1)
+    const Align Alignment = TLI->getPrefLoopAlignment(L);
+    if (Alignment == 1)
       continue; // Don't care about loop alignment.
 
     // If the block is cold relative to the function entry don't waste space
     // aligning it.
     BlockFrequency Freq = MBFI->getBlockFreq(ChainBB);
-    if (Freq < WeightedEntryFreq)
+    BlockFrequency BBSectionsFreq =
+        BBSections ? BBSectionsProfileReader
+                         ->getPropellerProfileForFunction(F->getName())
+                         .second.NodeFrequency.lookup(*ChainBB->getBBID())
+                   : 0;
+    if (BBSectionsFreq.getFrequency() != 0) {
+      if (BBSectionsFreq < BBSectionsEntryFreq * ColdProb)
+        continue;
+    } else if (Freq < WeightedEntryFreq) {
       continue;
+    }
 
     // If the block is cold relative to its loop header, don't align it
     // regardless of what edges into the block exist.
     MachineBasicBlock *LoopHeader = L->getHeader();
     BlockFrequency LoopHeaderFreq = MBFI->getBlockFreq(LoopHeader);
-    if (Freq < (LoopHeaderFreq * ColdProb))
+    if (BBSectionsFreq.getFrequency() == 0 && Freq < (LoopHeaderFreq * ColdProb)) {
       continue;
+    }
 
     // If the global profiles indicates so, don't align it.
     if (llvm::shouldOptimizeForSize(ChainBB, PSI, MBFI.get()) &&
@@ -2958,20 +2980,55 @@ void MachineBlockPlacement::alignBlocks() {
     // Force alignment if all the predecessors are jumps. We already checked
     // that the block isn't cold above.
     if (!LayoutPred->isSuccessor(ChainBB)) {
-      ChainBB->setAlignment(Align);
+      if (BBSections) {
+        if (BBSectionsFreq.getFrequency() != 0 && BBSectionsFreq >= BBSectionsEntryFreq * ColdProb) {
+          errs() << "Aligned with BB sections profile 1\n";
+        } else {
+          errs() << "Aligned with PGO profile 1\n";
+        }
+      }
+      if (BBSectionsFreq.getFrequency() != 0 && BBSectionsFreq >= BBSectionsEntryFreq * ColdProb) {
+        ChainBB->setAlignment(Align(Alignment.value() * 2));
+      } else {
+        ChainBB->setAlignment(Alignment);
+      }
       DetermineMaxAlignmentPadding();
       continue;
     }
 
+    BlockFrequency BBSectionsLayoutPredFreq =
+        BBSections ? BBSectionsProfileReader
+                         ->getPropellerProfileForFunction(F->getName())
+                         .second.NodeFrequency.lookup(*LayoutPred->getBBID())
+                   : 0;
+
     // Align this block if the layout predecessor's edge into this block is
     // cold relative to the block. When this is true, other predecessors make up
     // all of the hot entries into the block and thus alignment is likely to be
     // important.
     BranchProbability LayoutProb =
         MBPI->getEdgeProbability(LayoutPred, ChainBB);
+    BranchProbability BBSectionsLayoutProb =
+        BBSections
+            ? BBSectionsProfileReader->getEdgeProbability(
+                  F->getName(), *LayoutPred->getBBID(), *ChainBB->getBBID())
+            : BranchProbability();
     BlockFrequency LayoutEdgeFreq = MBFI->getBlockFreq(LayoutPred) * LayoutProb;
-    if (LayoutEdgeFreq <= (Freq * ColdProb)) {
-      ChainBB->setAlignment(Align);
+    BlockFrequency BBSectionsLayoutEdgeFreq =
+        BBSectionsLayoutProb.isUnknown()
+            ? 0
+            : BBSectionsLayoutPredFreq * BBSectionsLayoutProb;
+    if (BBSectionsFreq.getFrequency() != 0) {
+      if (BBSectionsLayoutEdgeFreq <= (BBSectionsFreq * ColdProb)) {
+        errs() << "Aligned with BB sections profile 2\n";
+        ChainBB->setAlignment(Align(Alignment.value() * 2));
+        DetermineMaxAlignmentPadding();
+      }
+    } else if (LayoutEdgeFreq <= (Freq * ColdProb)) {
+      if (BBSections) {
+        errs() << "Aligned with PGO profile 2\n";
+      }
+      ChainBB->setAlignment(Alignment);
       DetermineMaxAlignmentPadding();
     }
   }
@@ -3312,61 +3369,7 @@ void MachineBlockPlacement::findDuplicateCandidates(
   }
 }
 
-void MachineBlockPlacement::initDupThreshold() {
-  DupThreshold = 0;
-  if (!F->getFunction().hasProfileData())
-    return;
-
-  // We prefer to use prifile count.
-  uint64_t HotThreshold = PSI->getOrCompHotCountThreshold();
-  if (HotThreshold != UINT64_MAX) {
-    UseProfileCount = true;
-    DupThreshold = HotThreshold * TailDupProfilePercentThreshold / 100;
-    return;
-  }
-
-  // Profile count is not available, we can use block frequency instead.
-  BlockFrequency MaxFreq = 0;
-  for (MachineBasicBlock &MBB : *F) {
-    BlockFrequency Freq = MBFI->getBlockFreq(&MBB);
-    if (Freq > MaxFreq)
-      MaxFreq = Freq;
-  }
-
-  BranchProbability ThresholdProb(TailDupPlacementPenalty, 100);
-  DupThreshold = MaxFreq * ThresholdProb;
-  UseProfileCount = false;
-}
-
-bool MachineBlockPlacement::runOnMachineFunction(MachineFunction &MF) {
-  if (skipFunction(MF.getFunction()))
-    return false;
-
-  // Check for single-block functions and skip them.
-  if (std::next(MF.begin()) == MF.end())
-    return false;
-
-  F = &MF;
-  MBPI = &getAnalysis<MachineBranchProbabilityInfo>();
-  MBFI = std::make_unique<MBFIWrapper>(
-      getAnalysis<MachineBlockFrequencyInfo>());
-  MLI = &getAnalysis<MachineLoopInfo>();
-  TII = MF.getSubtarget().getInstrInfo();
-  TLI = MF.getSubtarget().getTargetLowering();
-  MPDT = nullptr;
-  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();
-
-  initDupThreshold();
-
-  // Initialize PreferredLoopExit to nullptr here since it may never be set if
-  // there are no MachineLoops.
-  PreferredLoopExit = nullptr;
-
-  assert(BlockToChain.empty() &&
-         "BlockToChain map should be empty before starting placement.");
-  assert(ComputedEdges.empty() &&
-         "Computed Edge map should be empty before starting placement.");
-
+void MachineBlockPlacement::applyBlockOrder(MachineFunction &MF) {
   unsigned TailDupSize = TailDupPlacementThreshold;
   // If only the aggressive threshold is explicitly set, use it.
   if (TailDupPlacementAggressiveThreshold.getNumOccurrences() != 0 &&
@@ -3430,15 +3433,83 @@ bool MachineBlockPlacement::runOnMachineFunction(MachineFunction &MF) {
       buildCFGChains();
     }
   }
+}
+
+void MachineBlockPlacement::initDupThreshold() {
+  DupThreshold = 0;
+  if (!F->getFunction().hasProfileData())
+    return;
+
+  // We prefer to use prifile count.
+  uint64_t HotThreshold = PSI->getOrCompHotCountThreshold();
+  if (HotThreshold != UINT64_MAX) {
+    UseProfileCount = true;
+    DupThreshold = HotThreshold * TailDupProfilePercentThreshold / 100;
+    return;
+  }
+
+  // Profile count is not available, we can use block frequency instead.
+  BlockFrequency MaxFreq = 0;
+  for (MachineBasicBlock &MBB : *F) {
+    BlockFrequency Freq = MBFI->getBlockFreq(&MBB);
+    if (Freq > MaxFreq)
+      MaxFreq = Freq;
+  }
+
+  BranchProbability ThresholdProb(TailDupPlacementPenalty, 100);
+  DupThreshold = MaxFreq * ThresholdProb;
+  UseProfileCount = false;
+}
+
+bool MachineBlockPlacement::runOnMachineFunction(MachineFunction &MF) {
+  if (skipFunction(MF.getFunction()))
+    return false;
+
+  // Check for single-block functions and skip them.
+  if (std::next(MF.begin()) == MF.end())
+    return false;
+
+  F = &MF;
+  MBPI = &getAnalysis<MachineBranchProbabilityInfo>();
+  BBSectionsProfileReader =
+      getAnalysisIfAvailable<BasicBlockSectionsProfileReader>();
+  MBFI =
+      std::make_unique<MBFIWrapper>(getAnalysis<MachineBlockFrequencyInfo>());
+  MLI = &getAnalysis<MachineLoopInfo>();
+  TII = MF.getSubtarget().getInstrInfo();
+  TLI = MF.getSubtarget().getTargetLowering();
+  MPDT = nullptr;
+  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();
+
+  initDupThreshold();
 
-  // Apply a post-processing optimizing block placement.
-  if (MF.size() >= 3 && EnableExtTspBlockPlacement &&
-      (ApplyExtTspWithoutProfile || MF.getFunction().hasProfileData())) {
-    // Find a new placement and modify the layout of the blocks in the function.
-    applyExtTsp();
+  // Initialize PreferredLoopExit to nullptr here since it may never be set if
+  // there are no MachineLoops.
+  PreferredLoopExit = nullptr;
 
-    // Re-create CFG chain so that we can optimizeBranches and alignBlocks.
-    createCFGChainExtTsp();
+  assert(BlockToChain.empty() &&
+         "BlockToChain map should be empty before starting placement.");
+  assert(ComputedEdges.empty() &&
+         "Computed Edge map should be empty before starting placement.");
+
+  if (!MF.hasBBSections()) {
+    applyBlockOrder(MF);
+
+    // Apply a post-processing optimizing block placement.
+    if (MF.size() >= 3 && EnableExtTspBlockPlacement &&
+        (ApplyExtTspWithoutProfile || MF.getFunction().hasProfileData())) {
+      // Find a new placement and modify the layout of the blocks in the
+      // function.
+      applyExtTsp();
+
+      // Re-create CFG chain so that we can optimizeBranches and alignBlocks.
+      createCFGChainFromCurrentBlockOrder();
+    }
+  } else {
+    createCFGChainFromCurrentBlockOrder();
+    // Reset alignment for all blocks.
+    for (MachineBasicBlock &MBB : MF)
+      MBB.setAlignment(Align(1));
   }
 
   optimizeBranches();
@@ -3607,7 +3678,7 @@ void MachineBlockPlacement::assignBlockOrder(
 #endif
 }
 
-void MachineBlockPlacement::createCFGChainExtTsp() {
+void MachineBlockPlacement::createCFGChainFromCurrentBlockOrder() {
   BlockToChain.clear();
   ComputedEdges.clear();
   ChainAllocator.DestroyAll();
@@ -3650,6 +3721,7 @@ public:
   void getAnalysisUsage(AnalysisUsage &AU) const override {
     AU.addRequired<MachineBranchProbabilityInfo>();
     AU.addRequired<MachineBlockFrequencyInfo>();
+    AU.addUsedIfAvailable<BasicBlockSectionsProfileReader>();
     AU.setPreservesAll();
     MachineFunctionPass::getAnalysisUsage(AU);
   }
diff --git a/llvm/lib/CodeGen/TargetPassConfig.cpp b/llvm/lib/CodeGen/TargetPassConfig.cpp
index 87ac68c834a8..c5127537de8b 100644
--- a/llvm/lib/CodeGen/TargetPassConfig.cpp
+++ b/llvm/lib/CodeGen/TargetPassConfig.cpp
@@ -146,6 +146,9 @@ static cl::opt<RunOutliner> EnableMachineOutliner(
 // manual override.
 static cl::opt<bool> DisableCFIFixup("disable-cfi-fixup", cl::Hidden,
                                      cl::desc("Disable the CFI fixup pass"));
+static cl::opt<bool> EnableAlignForBasicBlockSections(
+    "enable-align-basic-block-sections", cl::init(false), cl::Hidden,
+    cl::desc("Enable block alignment after basic block sections pass"));
 // Enable or disable FastISel. Both options are needed, because
 // FastISel is enabled by default with -fast, and we wish to be
 // able to enable or disable fast-isel independently from -O0.
@@ -1267,6 +1270,8 @@ void TargetPassConfig::addMachinePasses() {
           TM->getBBSectionsFuncListBuf()));
     }
     addPass(llvm::createBasicBlockSectionsPass());
+    if (EnableAlignForBasicBlockSections)
+      addPass(&MachineBlockPlacementID);
   } else if (TM->Options.EnableMachineFunctionSplitter ||
              EnableMachineFunctionSplitter) {
     const std::string ProfileFile = getFSProfileFile(TM);
